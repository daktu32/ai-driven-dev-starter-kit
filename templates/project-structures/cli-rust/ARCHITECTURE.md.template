# ã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆ - {{PROJECT_NAME}}

ãƒãƒ¼ã‚¸ãƒ§ãƒ³: 1.0  
ä½œæˆæ—¥: {{DATE}}  
ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆã‚¿ã‚¤ãƒ—: CLI Tool (Rust)

## ğŸ—ï¸ æ¦‚è¦

ã“ã®ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆã¯ã€{{PROJECT_NAME}}ã®ã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£è¨­è¨ˆæŒ‡é‡ã¨å®Ÿè£…ã‚¬ã‚¤ãƒ‰ãƒ©ã‚¤ãƒ³ã‚’æä¾›ã—ã¾ã™ã€‚Claude Codeãªã©ã®ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆãŒã‚¹ã‚±ãƒ«ãƒˆãƒ³ã‚¢ãƒ¬ãƒ³ã‚¸ã‚’è¡Œã†éš›ã®å‚è€ƒè³‡æ–™ã¨ã—ã¦ä½¿ç”¨ã—ã¦ãã ã•ã„ã€‚

## ğŸ“‹ æŠ€è¡“ã‚¹ã‚¿ãƒƒã‚¯

### è¨€èªãƒ»ãƒ©ãƒ³ã‚¿ã‚¤ãƒ 
- **è¨€èª**: Rust 2021 Edition
- **æœ€å°ã‚µãƒãƒ¼ãƒˆãƒãƒ¼ã‚¸ãƒ§ãƒ³**: 1.70+
- **ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸ãƒãƒãƒ¼ã‚¸ãƒ£ãƒ¼**: Cargo
- **ã‚¿ãƒ¼ã‚²ãƒƒãƒˆ**: Cross-platform (Windows, macOS, Linux)

### ä¸»è¦ã‚¯ãƒ¬ãƒ¼ãƒˆ
- **CLIè§£æ**: clap v4 (Command Line Argument Parser)
- **ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°**: anyhow / thiserror
- **éåŒæœŸãƒ©ãƒ³ã‚¿ã‚¤ãƒ **: tokio (å¿…è¦ã«å¿œã˜ã¦)
- **ã‚·ãƒªã‚¢ãƒ©ã‚¤ã‚¼ãƒ¼ã‚·ãƒ§ãƒ³**: serde + serde_json / serde_yaml
- **HTTP ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆ**: reqwest (APIé€£æºæ™‚)
- **ãƒ•ã‚¡ã‚¤ãƒ« I/O**: std::fs + walkdir

### é–‹ç™ºãƒ„ãƒ¼ãƒ«
- **ãƒ•ã‚©ãƒ¼ãƒãƒƒã‚¿ãƒ¼**: rustfmt
- **ãƒªãƒ³ã‚¿ãƒ¼**: clippy
- **ãƒ†ã‚¹ãƒˆ**: cargo test + criterion (ãƒ™ãƒ³ãƒãƒãƒ¼ã‚¯)
- **ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆ**: cargo doc
- **ãƒªãƒªãƒ¼ã‚¹**: cargo-release

## ğŸ¯ ã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£åŸå‰‡

### è¨­è¨ˆåŸå‰‡
1. **Single Responsibility**: å„ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã¯å˜ä¸€è²¬ä»»
2. **Fail Fast**: ã‚¨ãƒ©ãƒ¼ã¯æ—©æœŸç™ºè¦‹ãƒ»é©åˆ‡ãªå ±å‘Š
3. **Zero-Cost Abstractions**: ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹æœ€å„ªå…ˆ
4. **Type Safety**: Rustã®å‹ã‚·ã‚¹ãƒ†ãƒ æœ€å¤§æ´»ç”¨
5. **User Experience**: ç›´æ„Ÿçš„ã§è¦ªåˆ‡ãªCLI

### ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹åŸå‰‡
- **ãƒ¡ãƒ¢ãƒªåŠ¹ç‡**: æ‰€æœ‰æ¨©ã‚·ã‚¹ãƒ†ãƒ æ´»ç”¨ã€ä¸è¦ã‚³ãƒ”ãƒ¼å›é¿
- **ä¸¦è¡Œå‡¦ç†**: é©åˆ‡ãªä¸¦è¡Œãƒ»ä¸¦åˆ—å‡¦ç†å®Ÿè£…
- **èµ·å‹•é€Ÿåº¦**: é«˜é€Ÿãªèµ·å‹•æ™‚é–“
- **ãƒªã‚½ãƒ¼ã‚¹ç®¡ç†**: é©åˆ‡ãªãƒ•ã‚¡ã‚¤ãƒ«ãƒ»ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯ãƒªã‚½ãƒ¼ã‚¹ç®¡ç†

## ğŸ“ ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªæ§‹é€ 

```
{{PROJECT_NAME}}/
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ main.rs               # ã‚¨ãƒ³ãƒˆãƒªãƒ¼ãƒã‚¤ãƒ³ãƒˆ
â”‚   â”œâ”€â”€ lib.rs                # ãƒ©ã‚¤ãƒ–ãƒ©ãƒªãƒ«ãƒ¼ãƒˆï¼ˆå¿…è¦ã«å¿œã˜ã¦ï¼‰
â”‚   â”œâ”€â”€ cli/                  # CLIé–¢é€£
â”‚   â”‚   â”œâ”€â”€ mod.rs           # CLIãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«å®šç¾©
â”‚   â”‚   â”œâ”€â”€ args.rs          # å¼•æ•°å®šç¾©
â”‚   â”‚   â”œâ”€â”€ commands/        # ã‚µãƒ–ã‚³ãƒãƒ³ãƒ‰å®Ÿè£…
â”‚   â”‚   â”‚   â”œâ”€â”€ mod.rs
â”‚   â”‚   â”‚   â”œâ”€â”€ init.rs      # init ã‚µãƒ–ã‚³ãƒãƒ³ãƒ‰
â”‚   â”‚   â”‚   â”œâ”€â”€ run.rs       # run ã‚µãƒ–ã‚³ãƒãƒ³ãƒ‰
â”‚   â”‚   â”‚   â””â”€â”€ [command].rs # PRDè¦ä»¶ã«å¿œã˜ãŸã‚³ãƒãƒ³ãƒ‰
â”‚   â”‚   â””â”€â”€ output.rs        # å‡ºåŠ›ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆ
â”‚   â”œâ”€â”€ core/                # ã‚³ã‚¢ãƒ“ã‚¸ãƒã‚¹ãƒ­ã‚¸ãƒƒã‚¯
â”‚   â”‚   â”œâ”€â”€ mod.rs
â”‚   â”‚   â”œâ”€â”€ config.rs        # è¨­å®šç®¡ç†
â”‚   â”‚   â”œâ”€â”€ [domain].rs      # ãƒ‰ãƒ¡ã‚¤ãƒ³ãƒ­ã‚¸ãƒƒã‚¯
â”‚   â”‚   â””â”€â”€ processor.rs     # ä¸»è¦å‡¦ç†ãƒ­ã‚¸ãƒƒã‚¯
â”‚   â”œâ”€â”€ services/            # å¤–éƒ¨ã‚µãƒ¼ãƒ“ã‚¹é€£æº
â”‚   â”‚   â”œâ”€â”€ mod.rs
â”‚   â”‚   â”œâ”€â”€ api_client.rs    # API ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆ
â”‚   â”‚   â”œâ”€â”€ file_service.rs  # ãƒ•ã‚¡ã‚¤ãƒ«æ“ä½œ
â”‚   â”‚   â””â”€â”€ [service].rs     # PRDè¦ä»¶ã«å¿œã˜ãŸã‚µãƒ¼ãƒ“ã‚¹
â”‚   â”œâ”€â”€ utils/               # ãƒ¦ãƒ¼ãƒ†ã‚£ãƒªãƒ†ã‚£
â”‚   â”‚   â”œâ”€â”€ mod.rs
â”‚   â”‚   â”œâ”€â”€ error.rs         # ã‚¨ãƒ©ãƒ¼å®šç¾©
â”‚   â”‚   â”œâ”€â”€ logger.rs        # ãƒ­ã‚°ç®¡ç†
â”‚   â”‚   â”œâ”€â”€ validation.rs    # å…¥åŠ›æ¤œè¨¼
â”‚   â”‚   â””â”€â”€ helpers.rs       # ãƒ˜ãƒ«ãƒ‘ãƒ¼é–¢æ•°
â”‚   â””â”€â”€ types/               # å‹å®šç¾©
â”‚       â”œâ”€â”€ mod.rs
â”‚       â”œâ”€â”€ config.rs        # è¨­å®šå‹
â”‚       â”œâ”€â”€ result.rs        # çµæœå‹
â”‚       â””â”€â”€ [domain].rs      # ãƒ‰ãƒ¡ã‚¤ãƒ³å‹
â”œâ”€â”€ tests/                   # çµ±åˆãƒ†ã‚¹ãƒˆ
â”‚   â”œâ”€â”€ integration_test.rs
â”‚   â”œâ”€â”€ cli_test.rs
â”‚   â””â”€â”€ fixtures/           # ãƒ†ã‚¹ãƒˆãƒ‡ãƒ¼ã‚¿
â”œâ”€â”€ benches/                # ãƒ™ãƒ³ãƒãƒãƒ¼ã‚¯
â”‚   â””â”€â”€ benchmark.rs
â”œâ”€â”€ docs/                   # ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆ
â”œâ”€â”€ examples/               # ä½¿ç”¨ä¾‹
â”‚   â””â”€â”€ basic_usage.rs
â”œâ”€â”€ Cargo.toml              # ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆè¨­å®š
â”œâ”€â”€ Cargo.lock              # ä¾å­˜é–¢ä¿‚ãƒ­ãƒƒã‚¯
â”œâ”€â”€ README.md               # ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆèª¬æ˜
â””â”€â”€ .gitignore              # Gité™¤å¤–è¨­å®š
```

## ğŸ”§ ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆè¨­è¨ˆ

### Main Entry Point (main.rs)
**è²¬å‹™**: CLIå¼•æ•°è§£æã€ãƒ«ãƒ¼ãƒ†ã‚£ãƒ³ã‚°ã€ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°
```rust
// src/main.rs
use anyhow::Result;
use clap::Parser;

mod cli;
mod core;
mod services;
mod utils;
mod types;

use cli::args::Args;
use cli::commands;

#[tokio::main] // éåŒæœŸå‡¦ç†ãŒå¿…è¦ãªå ´åˆ
async fn main() -> Result<()> {
    // ãƒ­ã‚°åˆæœŸåŒ–
    utils::logger::init();
    
    // CLIå¼•æ•°è§£æ
    let args = Args::parse();
    
    // ã‚³ãƒãƒ³ãƒ‰å®Ÿè¡Œ
    match commands::execute(args).await {
        Ok(_) => Ok(()),
        Err(e) => {
            eprintln!("Error: {}", e);
            std::process::exit(1);
        }
    }
}
```

### CLI Arguments (cli/args.rs)
**è²¬å‹™**: ã‚³ãƒãƒ³ãƒ‰ãƒ©ã‚¤ãƒ³å¼•æ•°ãƒ»ã‚ªãƒ—ã‚·ãƒ§ãƒ³å®šç¾©
```rust
// src/cli/args.rs
use clap::{Parser, Subcommand};

#[derive(Parser)]
#[command(name = "{{PROJECT_NAME}}")]
#[command(version, about, long_about = None)]
pub struct Args {
    /// Verbose output
    #[arg(short, long)]
    pub verbose: bool,
    
    /// Configuration file path
    #[arg(short, long)]
    pub config: Option<String>,
    
    #[command(subcommand)]
    pub command: Commands,
}

#[derive(Subcommand)]
pub enum Commands {
    /// Initialize new project
    Init {
        /// Project name
        name: String,
        /// Template type
        #[arg(short, long)]
        template: Option<String>,
    },
    /// Run the main process
    Run {
        /// Input file path
        #[arg(short, long)]
        input: String,
        /// Output file path
        #[arg(short, long)]
        output: Option<String>,
    },
    // PRDè¦ä»¶ã«å¿œã˜ãŸè¿½åŠ ã‚³ãƒãƒ³ãƒ‰
}
```

### Command Implementation (cli/commands/)
**è²¬å‹™**: ã‚µãƒ–ã‚³ãƒãƒ³ãƒ‰ã®å…·ä½“çš„å®Ÿè£…
```rust
// src/cli/commands/run.rs
use anyhow::{Context, Result};
use crate::core::processor::Processor;
use crate::types::config::Config;

pub async fn run_command(
    input: &str,
    output: Option<&str>,
    config: &Config
) -> Result<()> {
    // å…¥åŠ›æ¤œè¨¼
    crate::utils::validation::validate_input_file(input)
        .context("Invalid input file")?;
    
    // ãƒ—ãƒ­ã‚»ãƒƒã‚µåˆæœŸåŒ–
    let processor = Processor::new(config);
    
    // å‡¦ç†å®Ÿè¡Œ
    let result = processor.process_file(input).await
        .context("Failed to process file")?;
    
    // çµæœå‡ºåŠ›
    match output {
        Some(path) => {
            crate::services::file_service::write_result(path, &result)
                .context("Failed to write output")?;
        }
        None => {
            println!("{}", result);
        }
    }
    
    Ok(())
}
```

### Core Business Logic (core/)
**è²¬å‹™**: ãƒ‰ãƒ¡ã‚¤ãƒ³ãƒ­ã‚¸ãƒƒã‚¯ã€ä¸»è¦ãªå‡¦ç†ãƒ•ãƒ­ãƒ¼
```rust
// src/core/processor.rs
use anyhow::Result;
use serde::{Deserialize, Serialize};
use crate::types::config::Config;

pub struct Processor {
    config: Config,
}

impl Processor {
    pub fn new(config: &Config) -> Self {
        Self {
            config: config.clone(),
        }
    }
    
    pub async fn process_file(&self, input_path: &str) -> Result<ProcessResult> {
        // ãƒ•ã‚¡ã‚¤ãƒ«èª­ã¿è¾¼ã¿
        let content = tokio::fs::read_to_string(input_path).await?;
        
        // ãƒ‡ãƒ¼ã‚¿è§£æ
        let data = self.parse_input(&content)?;
        
        // ãƒ“ã‚¸ãƒã‚¹ãƒ­ã‚¸ãƒƒã‚¯å®Ÿè¡Œ
        let processed = self.apply_business_logic(data)?;
        
        // çµæœãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆ
        Ok(ProcessResult {
            data: processed,
            metadata: self.generate_metadata(),
        })
    }
    
    fn parse_input(&self, content: &str) -> Result<InputData> {
        // å…¥åŠ›ãƒ‡ãƒ¼ã‚¿è§£æãƒ­ã‚¸ãƒƒã‚¯
        todo!("Implement based on PRD requirements")
    }
    
    fn apply_business_logic(&self, data: InputData) -> Result<OutputData> {
        // ãƒ“ã‚¸ãƒã‚¹ãƒ­ã‚¸ãƒƒã‚¯å®Ÿè£…
        todo!("Implement based on PRD requirements")
    }
}

#[derive(Debug, Serialize, Deserialize)]
pub struct ProcessResult {
    pub data: OutputData,
    pub metadata: Metadata,
}
```

### Error Handling (utils/error.rs)
**è²¬å‹™**: ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³å›ºæœ‰ã‚¨ãƒ©ãƒ¼å®šç¾©
```rust
// src/utils/error.rs
use thiserror::Error;

#[derive(Error, Debug)]
pub enum CliError {
    #[error("Configuration error: {0}")]
    Config(String),
    
    #[error("Input validation failed: {0}")]
    Validation(String),
    
    #[error("Processing error: {0}")]
    Processing(String),
    
    #[error("IO error: {0}")]
    Io(#[from] std::io::Error),
    
    #[error("Network error: {0}")]
    Network(#[from] reqwest::Error),
    
    #[error("Serialization error: {0}")]
    Serialization(#[from] serde_json::Error),
}

pub type CliResult<T> = Result<T, CliError>;
```

## ğŸ”„ ãƒ‡ãƒ¼ã‚¿ãƒ•ãƒ­ãƒ¼

### åŸºæœ¬å‡¦ç†ãƒ•ãƒ­ãƒ¼
```
1. CLI Arguments Parsing (clap)
2. Configuration Loading (config file + env vars)
3. Input Validation (file existence, format check)
4. Business Logic Execution (core processing)
5. External Service Integration (API calls, file operations)
6. Result Formatting (JSON, YAML, plain text)
7. Output Generation (stdout, file, structured format)
```

### ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°ãƒ•ãƒ­ãƒ¼
```
1. Error Detection (any processing stage)
2. Error Categorization (CliError variants)
3. Context Addition (anyhow context)
4. User-Friendly Message (helpful error reporting)
5. Exit Code Setting (appropriate exit status)
```

## ğŸ§ª ãƒ†ã‚¹ãƒˆæˆ¦ç•¥

### ãƒ¦ãƒ‹ãƒƒãƒˆãƒ†ã‚¹ãƒˆ
```rust
// src/core/processor.rs (ãƒ†ã‚¹ãƒˆä¾‹)
#[cfg(test)]
mod tests {
    use super::*;
    use crate::types::config::Config;

    #[tokio::test]
    async fn test_process_file_success() {
        let config = Config::default();
        let processor = Processor::new(&config);
        
        // ãƒ†ã‚¹ãƒˆãƒ‡ãƒ¼ã‚¿ã§ãƒ•ã‚¡ã‚¤ãƒ«å‡¦ç†ãƒ†ã‚¹ãƒˆ
        let result = processor.process_test_data("test input").await;
        assert!(result.is_ok());
    }
    
    #[test]
    fn test_input_validation() {
        // å…¥åŠ›æ¤œè¨¼ãƒ†ã‚¹ãƒˆ
        assert!(validate_input("valid input").is_ok());
        assert!(validate_input("").is_err());
    }
}
```

### çµ±åˆãƒ†ã‚¹ãƒˆ
```rust
// tests/cli_test.rs
use assert_cmd::Command;
use predicates::prelude::*;
use tempfile::TempDir;

#[test]
fn test_run_command_with_valid_input() {
    let temp_dir = TempDir::new().unwrap();
    let input_file = temp_dir.path().join("input.txt");
    std::fs::write(&input_file, "test data").unwrap();
    
    Command::cargo_bin("{{PROJECT_NAME}}")
        .unwrap()
        .arg("run")
        .arg("--input")
        .arg(input_file.to_str().unwrap())
        .assert()
        .success()
        .stdout(predicate::str::contains("processed"));
}
```

### ãƒ™ãƒ³ãƒãƒãƒ¼ã‚¯
```rust
// benches/benchmark.rs
use criterion::{black_box, criterion_group, criterion_main, Criterion};
use {{PROJECT_NAME}}::core::processor::Processor;

fn benchmark_processing(c: &mut Criterion) {
    let processor = Processor::new(&Default::default());
    
    c.bench_function("process_large_file", |b| {
        b.iter(|| {
            // å¤§ããªãƒ•ã‚¡ã‚¤ãƒ«å‡¦ç†ã®ãƒ™ãƒ³ãƒãƒãƒ¼ã‚¯
            processor.process_test_data(black_box("large test data"))
        });
    });
}

criterion_group!(benches, benchmark_processing);
criterion_main!(benches);
```

## ğŸ”’ ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£è€ƒæ…®äº‹é …

### å…¥åŠ›æ¤œè¨¼
```rust
// src/utils/validation.rs
use anyhow::{bail, Result};
use std::path::Path;

pub fn validate_input_file(path: &str) -> Result<()> {
    let path = Path::new(path);
    
    // ãƒ•ã‚¡ã‚¤ãƒ«å­˜åœ¨ç¢ºèª
    if !path.exists() {
        bail!("Input file does not exist: {}", path.display());
    }
    
    // ãƒ•ã‚¡ã‚¤ãƒ«ã‚µã‚¤ã‚ºç¢ºèª
    let metadata = path.metadata()?;
    if metadata.len() > 100_000_000 { // 100MBåˆ¶é™
        bail!("Input file too large: {} bytes", metadata.len());
    }
    
    // ãƒ‘ã‚¹ãƒˆãƒ©ãƒãƒ¼ã‚µãƒ«æ”»æ’ƒé˜²æ­¢
    if path.to_string_lossy().contains("..") {
        bail!("Invalid file path: {}", path.display());
    }
    
    Ok(())
}
```

### è¨­å®šãƒ•ã‚¡ã‚¤ãƒ«ç®¡ç†
- **æ©Ÿå¯†æƒ…å ±ã®åˆ†é›¢**: ç’°å¢ƒå¤‰æ•°ãƒ»è¨­å®šãƒ•ã‚¡ã‚¤ãƒ«ã®é©åˆ‡ãªä½¿ã„åˆ†ã‘
- **è¨­å®šæ¤œè¨¼**: ä¸æ­£ãªè¨­å®šå€¤ã®æ¤œå‡ºãƒ»æ‹’å¦
- **ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå€¤**: ã‚»ã‚­ãƒ¥ã‚¢ãªãƒ‡ãƒ•ã‚©ãƒ«ãƒˆè¨­å®š

## ğŸ“Š ç›£è¦–ãƒ»ãƒ­ã‚°

### ãƒ­ã‚°è¨­è¨ˆ
```rust
// src/utils/logger.rs
use tracing::{info, warn, error, debug};
use tracing_subscriber::{EnvFilter, FmtSubscriber};

pub fn init() {
    let subscriber = FmtSubscriber::builder()
        .with_env_filter(EnvFilter::from_default_env())
        .finish();
    
    tracing::subscriber::set_global_default(subscriber)
        .expect("Failed to set tracing subscriber");
}

// ä½¿ç”¨ä¾‹
pub fn log_processing_start(file: &str) {
    info!("Starting processing of file: {}", file);
}

pub fn log_error(operation: &str, error: &anyhow::Error) {
    error!("Failed to {}: {:?}", operation, error);
}
```

### ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹æ¸¬å®š
- **å®Ÿè¡Œæ™‚é–“**: ä¸»è¦å‡¦ç†ã®æ™‚é–“æ¸¬å®š
- **ãƒ¡ãƒ¢ãƒªä½¿ç”¨é‡**: ãƒ—ãƒ­ãƒ•ã‚¡ã‚¤ãƒªãƒ³ã‚°ãƒ„ãƒ¼ãƒ«æ´»ç”¨
- **CPUä½¿ç”¨ç‡**: ã‚·ã‚¹ãƒ†ãƒ ãƒªã‚½ãƒ¼ã‚¹ç›£è¦–

## ğŸš€ ãƒ“ãƒ«ãƒ‰ãƒ»é…å¸ƒ

### Cargo.tomlè¨­å®š
```toml
[package]
name = "{{PROJECT_NAME}}"
version = "1.0.0"
edition = "2021"
authors = ["{{AUTHOR}}"]
description = "{{PROJECT_DESCRIPTION}}"
license = "MIT"
repository = "https://github.com/user/{{PROJECT_NAME}}"

[dependencies]
clap = { version = "4.0", features = ["derive"] }
anyhow = "1.0"
thiserror = "1.0"
serde = { version = "1.0", features = ["derive"] }
serde_json = "1.0"
tokio = { version = "1.0", features = ["full"] }
reqwest = { version = "0.11", features = ["json"] }

[dev-dependencies]
assert_cmd = "2.0"
predicates = "3.0"
tempfile = "3.0"
criterion = "0.5"

[[bin]]
name = "{{PROJECT_NAME}}"
path = "src/main.rs"

[[bench]]
name = "benchmark"
harness = false
```

### ã‚¯ãƒ­ã‚¹ãƒ—ãƒ©ãƒƒãƒˆãƒ•ã‚©ãƒ¼ãƒ å¯¾å¿œ
```bash
# ãƒ“ãƒ«ãƒ‰ã‚¿ãƒ¼ã‚²ãƒƒãƒˆä¾‹
cargo build --target x86_64-unknown-linux-gnu
cargo build --target x86_64-pc-windows-gnu
cargo build --target x86_64-apple-darwin
```

## ğŸ”„ PRDè¦ä»¶å¯¾å¿œæŒ‡é‡

### Agentå‘ã‘å®Ÿè£…ã‚¬ã‚¤ãƒ€ãƒ³ã‚¹

**1. PRDåˆ†ææ™‚ã®é‡ç‚¹ç¢ºèªäº‹é …**
- **ã‚³ãƒãƒ³ãƒ‰ä½“ç³»**: ã©ã®ã‚ˆã†ãªã‚µãƒ–ã‚³ãƒãƒ³ãƒ‰ãŒå¿…è¦ã‹
- **å…¥å‡ºåŠ›å½¢å¼**: ãƒ•ã‚¡ã‚¤ãƒ«ã€æ¨™æº–å…¥å‡ºåŠ›ã€ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯
- **ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹è¦ä»¶**: å‡¦ç†é€Ÿåº¦ã€ãƒ¡ãƒ¢ãƒªä½¿ç”¨é‡
- **ãƒ¦ãƒ¼ã‚¶ãƒ“ãƒªãƒ†ã‚£**: ã‚¨ãƒ©ãƒ¼ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã€ãƒ˜ãƒ«ãƒ—æ–‡æ›¸

**2. ã‚³ãƒãƒ³ãƒ‰è¨­è¨ˆã®æ±ºå®šåŸºæº–**
- **ç›´æ„Ÿæ€§**: Unixå“²å­¦ã«æº–æ‹ ã—ãŸè¨­è¨ˆ
- **ä¸€è²«æ€§**: å¼•æ•°ãƒ»ã‚ªãƒ—ã‚·ãƒ§ãƒ³ã®å‘½åè¦å‰‡çµ±ä¸€
- **æ‹¡å¼µæ€§**: æ–°ã—ã„ã‚µãƒ–ã‚³ãƒãƒ³ãƒ‰è¿½åŠ ã®å®¹æ˜“ã•
- **å¾Œæ–¹äº’æ›æ€§**: æ—¢å­˜ä½¿ç”¨æ–¹æ³•ã®ä¿æŒ

**3. ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹æœ€é©åŒ–æŒ‡é‡**
- **ä¸¦è¡Œå‡¦ç†**: CPUé›†ç´„çš„å‡¦ç†ã®ä¸¦åˆ—åŒ–
- **ãƒ¡ãƒ¢ãƒªåŠ¹ç‡**: ã‚¹ãƒˆãƒªãƒ¼ãƒŸãƒ³ã‚°å‡¦ç†ã€é©åˆ‡ãªæ‰€æœ‰æ¨©ç®¡ç†
- **I/Oæœ€é©åŒ–**: éåŒæœŸI/Oã€ãƒãƒƒãƒ•ã‚¡ãƒªãƒ³ã‚°
- **èµ·å‹•é€Ÿåº¦**: ä¾å­˜é–¢ä¿‚æœ€å°åŒ–ã€é…å»¶åˆæœŸåŒ–

**4. ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°æˆ¦ç•¥**
- **æ—©æœŸç™ºè¦‹**: å…¥åŠ›æ¤œè¨¼ã®å¾¹åº•
- **åˆ†ã‹ã‚Šã‚„ã™ã•**: ãƒ¦ãƒ¼ã‚¶ãƒ¼ãƒ•ãƒ¬ãƒ³ãƒ‰ãƒªãƒ¼ãªã‚¨ãƒ©ãƒ¼ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸
- **å›å¾©å¯èƒ½æ€§**: é©åˆ‡ãªãƒªãƒˆãƒ©ã‚¤ãƒ»ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯
- **ãƒ‡ãƒãƒƒã‚°æ”¯æ´**: è©³ç´°ãƒ­ã‚°ã€ã‚¹ã‚¿ãƒƒã‚¯ãƒˆãƒ¬ãƒ¼ã‚¹

**5. é…å¸ƒãƒ»é‹ç”¨è€ƒæ…®**
- **ã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«æ–¹æ³•**: cargo install, ãƒã‚¤ãƒŠãƒªé…å¸ƒ, ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸ãƒãƒãƒ¼ã‚¸ãƒ£ãƒ¼
- **è¨­å®šç®¡ç†**: è¨­å®šãƒ•ã‚¡ã‚¤ãƒ«ã€ç’°å¢ƒå¤‰æ•°ã€ã‚³ãƒãƒ³ãƒ‰ãƒ©ã‚¤ãƒ³å¼•æ•°
- **ã‚¢ãƒƒãƒ—ãƒ‡ãƒ¼ãƒˆ**: ãƒãƒ¼ã‚¸ãƒ§ãƒ³ç®¡ç†ã€è‡ªå‹•æ›´æ–°æ©Ÿèƒ½
- **ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆ**: man ãƒšãƒ¼ã‚¸ã€ä½¿ç”¨ä¾‹ã€ãƒˆãƒ©ãƒ–ãƒ«ã‚·ãƒ¥ãƒ¼ãƒ†ã‚£ãƒ³ã‚°

---

**ğŸ“Œ é‡è¦**: ã“ã®ã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£ã¯ {{PROJECT_NAME}} ã® PRDè¦ä»¶ã«åŸºã¥ã„ã¦æŸ”è»Ÿã«èª¿æ•´ã—ã¦ãã ã•ã„ã€‚ç‰¹ã«ã‚³ãƒãƒ³ãƒ‰ä½“ç³»ã€ãƒ‡ãƒ¼ã‚¿å‡¦ç†ãƒ•ãƒ­ãƒ¼ã€ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹è¦ä»¶ã«ã¤ã„ã¦ã¯ã€å…·ä½“çš„ãªè¦ä»¶ã«å¿œã˜ã¦æœ€é©åŒ–ã‚’è¡Œã£ã¦ãã ã•ã„ã€‚